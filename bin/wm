#!/usr/bin/env ruby

#
# RaWM Ruby as Window Manager
#
# An elliptical window manager
# See commentation in ../lib/wm/wm_ellipse.rb for overview
#
# ppibburr tulnor33@gmail.com
#

require File.join(ENV["XCB_PATH"],"lib","xcb.rb")
require File.expand_path(File.join(File.dirname(__FILE__),"..","lib","wm.rb"))
require File.expand_path(File.join(File.dirname(__FILE__),"..","lib","wm","fx_fade.rb"))

class MyWM < WM::EllipseWM
  # enable some common debug utils
  # ie, swap_alt_ctrl, keybinds with ALT mask become CTRL mask
  # usefull in Xnest or Xephyr
  extend WM::DebugWM
  
  # Multiple WorkSpace support
  include WM::EllipseWS
  
  class self::Client < WM::EllipseWM::Client
    include WM::EllipseWS::Client 
    
    # Blue looks nice
    BORDER = WM::BLUE # the focused window border color
    
    # Effects only work with a composition manager running
    # Tested with:
    #   xcompmgr - very buggy
    #   unagi    - buggy
    #   compton  - awesome
    #
    #
    # Shutdown the composition manager to regain input
    #
    # Comment the next line to disable composition effects 
    include WM::FX::Fade 
    
    # We write the focused window id
    STATUS = "#{ENV['HOME']}/.mywm_status.txt"
    
    # overide to update the status file
    # dzen2 status tool @ /path/to/RaWM/scripts/statusbar.rb (requires xdotool, dzen2 and i3status)
    def focus
      super
      
      WM::log :debug do
        "in focus(), window is_mapped? : #{get_window.is_mapped?}"
      end
      
      File.open(STATUS,"w") do |f|
        f.puts "#{window.id}"
      end
    end
  end
  
  def manage_existing(*o)
    super
    at_startup()
  end
  
  # Do the stuff to do at startup (after exisiting windows are managed)
  def at_startup()
    STARTUP.each do |t|
      send *t
    end
  end
  
  STARTUP = []
  
  # Add something to the statup list
  def self.add_startup_task *task
    STARTUP << task
  end
   
  def initialize *o
    super  
    
    @active_client_width = 950
    @active_client_height += 70
    
	#
	# Key bindings
	#

	add_key_binding :Alt, :t,    :spawn, "x-terminal-emulator"      # launch terminal
	add_key_binding :Alt, :w,    :spawn, "x-www-browser"            # launch web browser
	add_key_binding :Alt, :p,    :spawn, "dmenu_run"                # launch dmenu launcher  
	add_key_binding :Alt, :m,    :spawn, "amixer set Master mute"   # mute volume
	add_key_binding :Alt, :u,    :spawn, "amixer set Master unmute" # unmute volume	
	add_key_binding :Alt, :Up,   :spawn, "amixer set Master 2+"     # raise volume by 2	
	add_key_binding :Alt, :Down, :spawn, "amixer set Master 2-"     # lower volume by 2			
  end
end

begin
  if ARGV.index('--debug')
    WM::LOG.level = Logger::DEBUG
  else
    WM::LOG.level = Logger::INFO
  end
  
  if ARGV.index('--swap-alt-ctrl')
    MyWM.swap_alt_ctrl()
  end
  
  print_key_bindings = false
  if ARGV.index('--print-key-bindings')
    print_key_bindings = true
  end

  # Use the arrow instead of the X
  MyWM::add_startup_task :spawn,"xsetroot -cursor_name  left_ptr"
  
  # Set a background
  MyWM::add_startup_task :spawn,"feh --bg-scale /home/ppibburr/el6.png"
  
  # Start the composition manager
  MyWM::add_startup_task :spawn,"compton -cCfF"
  
  m = MyWM.new(WM::SCREEN,WM::CONNECTION)

  if print_key_bindings
    m.key_bindings.each_pair do |mod,vv|
      mod = WM::KeyMap.find_symbol_for(mod)
      
      vv.each_pair do |key,v|
        key = WM::KeyMap.find_symbol_for(key)
      
        p [mod,key].push(*v)
      end
    end
    
    exit(0)  
  end
 
  Signal.trap("INT") do
    m.on_abort(1)
  end
  
  if ARGV[0] == "--status"
    path = File.expand_path(File.join(File.dirname(__FILE__),"..","scripts","statusbar.rb"))
    MyWM::add_startup_task :spawn,"ruby #{path}"
  end

  m.main
rescue => e
  puts "OOPS!! #{e} happened."
  exit(1)
end
